#!/bin/bash

################################################################################
#   "                    m           ""#    ""#          #######################
# mmm    m mm    mmm   mm#mm   mmm     #      #    m   m #######################
#   #    #"  #  #   "    #    "   #    #      #    "m m" #######################
#   #    #   #   """m    #    m"""#    #      #     #m#  #######################
# mm#mm  #   #  "mmm"    "mm  "mm"#    "mm    "mm   "#   #######################
#                                                   m"   #######################
#                                                  ""    #######################
################################################################################

# Global variables #############################################################
# Data used throughout the `instally` experience.
################################################################################

# Options
VERBOSE_MODE=false;

# OS
OS_NAME=$(grep '^NAME=' /etc/os-release | cut -d= -f2 | tr -d '"');
OS_PRETTY_NAME=$(grep '^PRETTY_NAME=' /etc/os-release | cut -d= -f2 | \
  tr -d '"');
OS_IS_DEBIAN_BASED=false;
OS_IS_RHEL_BASED=false;
OS_IS_SUSE_BASED=false;

# package.json
PACKAGE_JSON="$HOME/.instally/package.json";

# instally.conf
INSTALLY_CONF="$HOME/.instally/instally.conf";

# Packages
PACKAGES_INSTALLED=0;
ACTIVE_GROUP="";

# apt
APT_IS_UPDATED=false;

# npm
NODE_VERSION_MANAGER_NEWLY_INSTALLED=false;
NEWLY_INSTALLED_NODE_VERSION_MANAGER="";

# UI
GUM_CHOOSE_CURSOR="‚ñ∂";
GUM_CHOOSE_CURSOR_PREFIX="¬∑";
GUM_CHOOSE_SELECTED_PREFIX="x";
GUM_CHOOSE_UNSELECTED_PREFIX="¬∑";

# Colors
COLOR_ACTIVE="#E60000";
COLOR_ACCENT="#2CB0C4";
GUM_CHOOSE_CURSOR_FOREGROUND="$COLOR_ACTIVE";
GUM_CHOOSE_SELECTED_FOREGROUND="$COLOR_ACCENT";
GUM_CONFIRM_SELECTED_BACKGROUND="$COLOR_ACTIVE";

# Delimiter
DELIMITER="|";
IFS="$DELIMITER";

# OS Detection #################################################################
# Functions related to detecting the OS in order to determine the default
# package manager available.
################################################################################

# Detects whether the user's OS is Debian-based,
# Assigns `OS_IS_DEBIAN_BASED` to true if so.
os_is_debian_based () {
  if \
    [ "$OS_NAME" = "Pop!_OS" ] || \
    [ "$OS_NAME" = "Ubuntu" ] || \
    [ "$OS_NAME" = "Debian GNU/Linux" ] || \
    [ "$OS_NAME" = "Linux Mint" ] || \
    [ "$OS_NAME" = "elementary OS" ] || \
    [ "$OS_NAME" = "Zorin OS" ] || \
    [ "$OS_NAME" = "MX Linux" ] || \
    [ "$OS_NAME" = "Raspberry Pi OS" ] || \
    [ "$OS_NAME" = "Deepin" ] || \
    [ "$OS_NAME" = "ArcoLinux" ] || \
    [ "$OS_NAME" = "Peppermint Linux" ] || \
    [ "$OS_NAME" = "Bodhi Linux" ]; then
    OS_IS_DEBIAN_BASED=true;
  fi
}

# Detects whether the user's OS is RHEL-based,
# Assigns `OS_IS_RHEL_BASED` to true if so.
os_is_rhel_based () {
  if \
    [ "$OS_NAME" = "Fedora Linux" ] || \
    [ "$OS_NAME" = "Red Hat Enterprise Linux" ] || \
    [ "$OS_NAME" = "CentOS Linux" ] || \
    [ "$OS_NAME" = "Oracle Linux Server" ] || \
    [ "$OS_NAME" = "Amazon Linux" ] || \
    [ "$OS_NAME" = "Rocky Linux" ] || \
    [ "$OS_NAME" = "AlmaLinux" ] || \
    [ "$OS_NAME" = "OpenMandriva Lx" ] ||\
    [ "$OS_NAME" = "Mageia" ] ; then
    OS_IS_RHEL_BASED=true;
  fi
}

# Detects whether the user's OS is SUSE-based,
# Assigns `OS_IS_SUSE_BASED` to true if so.
os_is_suse_based () {
  if \
    [ "$OS_NAME" = "openSUSE" ] || \
    [ "$OS_NAME" = "openSUSE Tumbleweed" ] || \
    [ "$OS_NAME" = "SUSE Enterprise Linux Server" ]; then
    OS_IS_SUSE_BASED=true;
  fi
}

# Detects the OS's lineage so as to determine the default package manager.
check_os () {
  os_is_debian_based;
  os_is_rhel_based;
  os_is_suse_based;
}

# Dependencies #################################################################
# Functions related to detecting and installing `instally`'s dependencies.
################################################################################

# Checks for `instally`'s dependencies, and installs whatever dependencies are
# missing.
check_dependencies () {
  # Detect missing dependencies,
  if ! package_is_installed curl || \
    ! package_is_installed gum || \
    ! package_is_installed jq; then
    printf "Welcome to instally! You're using $OS_PRETTY_NAME.\n";
    printf "We need some dependencies to get started:\n";
    # Install curl:
    if ! package_is_installed curl; then
      print_dependency_needed "curl";
      if $OS_IS_DEBIAN_BASED; then
        install_package_apt curl curl;
      elif $OS_IS_RHEL_BASED; then
        install_package_dnf curl curl;
      elif $OS_IS_SUSE_BASED; then
        install_package_zypper curl curl;
      fi
    fi
    # Install gum:
    if ! package_is_installed gum; then
      print_dependency_needed "gum";
      install_dependency_gum;
    fi
    # Install jq:
    if ! package_is_installed jq; then
      print_dependency_needed "jq";
      if $OS_IS_DEBIAN_BASED; then
        install_package_apt jq jq;
      elif $OS_IS_RHEL_BASED; then
        if [ "$OS_NAME" = "Fedora Linux" ]; then
          install_package_dnf jq jq;
        else
          install_dependency_jq_using_binary;
        fi
      elif $OS_IS_SUSE_BASED; then
        install_package_zypper jq jq;
      else
        install_dependency_jq_using_binary;
      fi
    fi
  fi
  if package_is_installed curl && \
    package_is_installed gum && \
    package_is_installed jq; then
    return 0;
  fi
}

# Installs gum for `instally`'s interactivity.
install_dependency_gum () {
  # If the OS is Debian-based, use apt to install gum;
  if $OS_IS_DEBIAN_BASED; then
    sudo mkdir -p /etc/apt/keyrings;
    curl -fsSL https://repo.charm.sh/apt/gpg.key | \
      sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg;
    echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | \
      sudo tee /etc/apt/sources.list.d/charm.list;
    install_package_apt gum gum;
  # If OS is RHEL-based,
  elif $OS_IS_RHEL_BASED; then
    echo "[charm]
name=Charm
baseurl=https://repo.charm.sh/yum/
enabled=1
gpgcheck=1
gpgkey=https://repo.charm.sh/yum/gpg.key" | \
  sudo tee /etc/yum.repos.d/charm.repo;
    # Use dnf to install gum,
    if package_is_installed dnf; then
      install_package_dnf gum gum;
      if [ $? == 0 ]; then
        return 0;
      fi
    # Or use yum in absence of dnf to install gum.
    else 
      install_package_yum gum gum;
      if [ $? == 0 ]; then
        return 0;
      fi
    fi
  # Otherwise, install go to install gum.
  else
    if ! package_is_installed go; then
      print_dependency_needed "gum" "Go";
      install_package_manager_go;
      if [ $? == 0 ]; then
        install_dependency_gum_using_go;
      fi
    else
      install_dependency_gum_using_go;
      if ! package_is_installed gum; then
        printf "\n";
        print_error "Go is installed, and gum also might be installed, but Go \
is not finding gum.\n  Ensure your Go binaries (/go/bin) are included in your \
PATH variable below:\n\n  $PATH\n\n See \
https://github.com/jelizaga/instally/#gum-is-installed-but-wont-run for help.";
        exit 1;
      fi
    fi
  fi
}

# Installs `gum` for `instally`s interactivity using go.
install_dependency_gum_using_go () {
  print_installing "gum" "gum" "go";
  # Get the gum tarball off the GitHub repo,
  wget -qP $HOME/Downloads \
    https://github.com/charmbracelet/gum/releases/download/v0.10.0/gum-0.10.0.tar.gz \
    > /dev/null;
  # Extract the tarball in `~/Downloads/gum`,
  mkdir $HOME/Downloads/gum;
  tar -zxvf $HOME/Downloads/gum-0.10.0.tar.gz -C $HOME/Downloads/gum > \
    /dev/null;
  cd $HOME/Downloads/gum;
  # Install gum using go,
  go install > /dev/null;
  # Clean up `/gum` and its tarball.
  rm -rf $HOME/Downloads/gum;
  rm -rf $HOME/Downloads/gum/gum-0.10.0.tar.gz;
}

# Installs `jq` for `instally`'s data parsing using a downloaded binary.
install_dependency_jq_using_binary () {
  print_installing "jq" "jq" "downloaded binary \
(https://stedolan.github.io/jq/download/)";
  wget -qP \
    $HOME/Downloads https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64 \
    > /dev/null;
  if [ $? == 0 ]; then
    if ! [ -e $HOME/.local/bin ]; then
      mkdir $HOME/.local/bin;
    fi
    mv $HOME/Downloads/jq-linux64 $HOME/.local/bin/jq; 
    chmod +x $HOME/.local/bin/jq;
    print_installed "jq" "downloaded binary \
(https://stedolan.github.io/jq/download/)";
  fi
}

# Config #######################################################################
# Functions related to reading `instally`'s config file and setting configured
# values.
################################################################################

# Checks and applies the config file's user-customized values.
check_conf () {
  if [ -e $INSTALLY_CONF ]; then
    CONF_COLOR_ACTIVE=$(awk -F '=' '/^COLOR_ACTIVE=/ {print $2}' \
      "$INSTALLY_CONF");
    if ! [ -z "$CONF_COLOR_ACTIVE" ]; then
      COLOR_ACTIVE="$CONF_COLOR_ACTIVE";
      GUM_CHOOSE_CURSOR_FOREGROUND="$COLOR_ACTIVE";
      GUM_CONFIRM_SELECTED_BACKGROUND="$COLOR_ACTIVE";
    fi
    CONF_COLOR_ACCENT=$(awk -F '=' '/^COLOR_ACCENT=/ {print $2}' \
      "$INSTALLY_CONF");
    if ! [ -z "$CONF_COLOR_ACCENT" ]; then
      COLOR_ACCENT="$CONF_COLOR_ACCENT";
      GUM_CHOOSE_SELECTED_FOREGROUND="$COLOR_ACCENT";
    fi
    CONF_CURSOR=$(awk -F '=' '/^CURSOR=/ {print $2}' \
      "$INSTALLY_CONF");
    if ! [ -z "$CONF_CURSOR" ]; then
      GUM_CHOOSE_CURSOR="$CONF_CURSOR";
    fi
    CONF_CHOOSE_DEFAULT=$(awk -F '=' '/^CHOOSE_DEFAULT=/ {print $2}' \
      "$INSTALLY_CONF");
    if ! [ -z "$CONF_CHOOSE_DEFAULT" ]; then
      GUM_CHOOSE_CURSOR_PREFIX="$CONF_CHOOSE_DEFAULT";
      GUM_CHOOSE_UNSELECTED_PREFIX="$CONF_CHOOSE_DEFAULT";
    fi
    CONF_CHOOSE_SELECTED=$(awk -F '=' '/^CHOOSE_SELECTED=/ {print $2}' \
      "$INSTALLY_CONF");
    if ! [ -z "$CONF_CHOOSE_SELECTED" ]; then
      GUM_CHOOSE_SELECTED_PREFIX="$CONF_CHOOSE_SELECTED";
    fi
  fi
}

# File system ##################################################################
# Functions related to `instally`'s interactions with the file system.
################################################################################

# Checks for `~/.instally` & `~/.instally/package.json`.
# Creates either if they've yet to exist.
check_package_json () {
  if ! [ -e $HOME/.instally ]; then
    create_instally_dir;
    create_package_json;
    prompt_edit_package_json;
    check_package_json;
  elif ! [ -e $HOME/.instally/package.json ]; then
    create_package_json;
    prompt_edit_package_json;
    check_package_json;
  elif ! [ -s $PACKAGE_JSON ]; then
    print_empty "package.json" "üìí";
    prompt_edit_package_json;
    check_package_json;
  else
    return 0;
  fi
}

# Creates `~/.instally/package.json` and reports this action.
create_package_json () {
  touch $HOME/.instally/package.json;
  print_created "~/.instally/package.json" "üìí";
}

# Creates `~/.instally` and reports this action.
create_instally_dir () {
  mkdir $HOME/.instally;
  print_created "~/.instally" "üìÅ";
}

# Updates a field in `instally.conf`.
# Args:
#   `$1` - Field to be updated.
#   `$2` - Value with which to update the field.
update_instally_conf () {
  local FIELD=$1;
  local VALUE=$2;
  if [ -e $INSTALLY_CONF ]; then
    if grep -q "$FIELD" $INSTALLY_CONF; then
      sed -i "s/^${FIELD}=.*/${FIELD}=${VALUE}/" $INSTALLY_CONF;
    else
      echo "$FIELD=$VALUE" >> $INSTALLY_CONF;
    fi
  else
    touch $INSTALLY_CONF;
    echo "$FIELD=$VALUE" >> $INSTALLY_CONF;
  fi
}

# Menus ########################################################################
# `instally`'s system of interactive menus and prompts.
################################################################################

# Main menu presented on start-up and at the completion of certain tasks.
menu_main () {
  print_title
  print_os
  printf "\n"
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "Install Packages" \
    "Settings" \
    "Quit");
    print_input_selection "$SELECTED";
  case $SELECTED in
    "Install Packages")
      menu_select_groups;
      ;;
    "Settings")
      menu_settings;
      ;;
    "Quit")
      exit 0;
      ;;
    *)
      exit 1;
      ;;
  esac
}

# Settings menu where `instally` can be configured.
menu_settings () {
  print_section_heading "Settings";
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "package.json" \
    "Customize Appearance" \
    "Back");
  print_input_selection "$SELECTED";
  case $SELECTED in
    "package.json")
      menu_package_json;
      ;;
    "Customize Appearance")
      menu_customize_appearance;
      ;;
    "Back")
      menu_main;
      ;;
    *)
      exit 1;
  esac
}

# Menu wherein the user can configure package.json-related things.
menu_package_json () {
  print_section_heading "Settings / package.json";
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "Edit package.json" \
    "Select package.json" \
    "Back");
  print_input_selection "$SELECTED";
  case $SELECTED in
    "Edit package.json")
      print_section_heading "Edit package.json";
      OLD_MODIFY=$(stat -L $PACKAGE_JSON | grep "Modify");
      if [ -z $EDITOR ]; then
        nano $PACKAGE_JSON;
      elif [ -n $EDITOR ]; then
        $EDITOR $PACKAGE_JSON;
      fi
      sleep 2;
      NEW_MODIFY=$(stat -L $PACKAGE_JSON | grep "Modify");
      if [ "$OLD_MODIFY" != "$NEW_MODIFY" ]; then
        printf "üíæ package.json edits saved.\n";
      else
        printf "No package.json edits made.\n";
      fi
      menu_package_json;
      ;;
    "Select package.json")
      print_section_heading "Select package.json";
      printf "$(gum style --italic "Enter the path to the") \
$(gum style --bold --italic "package.json") \
$(gum style --italic "file you would like to use.")\n";
      printf "$(gum style --bold "Current package.json:") $PACKAGE_JSON\n";
      NEW_PACKAGE_JSON=$(gum input --placeholder "/path/to/package.json/file");
      #NEW_PACKAGE_JSON=$(gum file $HOME);
      if ! [ -z "$NEW_PACKAGE_JSON" ]; then
        PACKAGE_JSON=$NEW_PACKAGE_JSON;
      fi
      printf "$(gum style --bold "New package.json:") $PACKAGE_JSON\n";
      menu_package_json;
      ;;
    "Back")
      menu_settings;
      ;;
    *)
      exit 1;
  esac
}

# Menu wherein the user can choose what parts of `instally`'s appearance to
# customize.
menu_customize_appearance () {
  print_section_heading "Settings / Customize Appearance";
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "Customize Colors" \
    "Customize Interface" \
    "Back");
  print_input_selection "$SELECTED";
  case $SELECTED in
    "Customize Colors")
      menu_customize_colors;
      ;;
    "Customize Interface")
      menu_customize_interface;
      ;;
    "Back")
      menu_settings;
  esac
}

# Menu wherein the user can customize `instally`'s colors.
menu_customize_colors () {
  print_section_heading "Settings / Customize Appearance / Colors";
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "Accent Color" \
    "Active Color" \
    "Back");
  print_input_selection "$SELECTED";
  case $SELECTED in
    "Accent Color")
      print_section_heading "Accent Color";
      printf "$(gum style --italic "Enter a new accent color.")\n";
      printf "$(gum style --bold "Current") \
$(gum style --bold "accent color:") \
$(gum style --foreground $COLOR_ACCENT "$COLOR_ACCENT")\n";
      NEW_COLOR_ACCENT=$(gum input --placeholder "010");
      if ! [ -z "$NEW_COLOR_ACCENT" ]; then
        COLOR_ACCENT=$NEW_COLOR_ACCENT;
        GUM_CHOOSE_SELECTED_FOREGROUND="$COLOR_ACCENT";
        update_instally_conf "COLOR_ACCENT" "$COLOR_ACCENT";
      fi
      printf "$(gum style --bold "New") \
$(gum style --bold "accent color:") \
$(gum style --foreground $COLOR_ACCENT "$COLOR_ACCENT")\n";
      menu_customize_colors;
      ;;
    "Active Color")
      print_section_heading "Active Color";
      printf "$(gum style --italic "Enter a new active color.")\n";
      printf "$(gum style --bold "Current") \
$(gum style --bold "active color:") \
$(gum style --foreground $COLOR_ACTIVE "$COLOR_ACTIVE")\n";
      NEW_COLOR_ACTIVE=$(gum input --placeholder "010");
      if ! [ -z "$NEW_COLOR_ACTIVE" ]; then
        COLOR_ACTIVE=$NEW_COLOR_ACTIVE;
        GUM_CHOOSE_CURSOR_FOREGROUND="$COLOR_ACTIVE";
        GUM_CONFIRM_SELECTED_BACKGROUND="$COLOR_ACTIVE";
        update_instally_conf "COLOR_ACTIVE" "$COLOR_ACTIVE";
      fi
      printf "$(gum style --bold "New") \
$(gum style --bold "active color:") \
$(gum style --foreground $COLOR_ACTIVE "$COLOR_ACTIVE")\n";
      menu_customize_colors;
      ;;
    "Back")
      menu_customize_appearance;
      ;;
    esac
}

# Menu wherein the user can customize `instally`'s interface elements.
menu_customize_interface () {
  print_section_heading "Settings / Customize Appearance / Interface";
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "Cursor" \
    "Default Menu Item" \
    "Selected Menu Item" \
    "Back");
  print_input_selection "$SELECTED";
  case $SELECTED in
    "Cursor")
      print_section_heading "Cursor";
      printf "$(gum style --italic "Enter a new cursor.")\n";
      printf "$(gum style --bold "Old cursor:") $GUM_CHOOSE_CURSOR\n";
      NEW_CURSOR=$(gum input --placeholder ">");
      if ! [ -z "$NEW_CURSOR" ]; then
        GUM_CHOOSE_CURSOR=$NEW_CURSOR;
        update_instally_conf "CURSOR" "$GUM_CHOOSE_CURSOR";
      fi
      printf "$(gum style --bold "New cursor:") $GUM_CHOOSE_CURSOR\n";
      menu_customize_interface;
      ;;
    "Default Menu Item")
      print_section_heading "Default Menu Item";
      printf "$(gum style --italic "Enter a new default menu item prefix.")\n";
      printf "$(gum style --bold "Old default menu item prefix:") \
$GUM_CHOOSE_CURSOR_PREFIX\n";
      NEW_DEFAULT_MENU_ITEM_PREFIX=$(gum input --placeholder "n");
      if ! [ -z "$NEW_DEFAULT_MENU_ITEM_PREFIX" ]; then
        GUM_CHOOSE_CURSOR_PREFIX=$NEW_DEFAULT_MENU_ITEM_PREFIX;
        GUM_CHOOSE_UNSELECTED_PREFIX=$NEW_DEFAULT_MENU_ITEM_PREFIX;
        update_instally_conf "CHOOSE_DEFAULT" "$GUM_CHOOSE_CURSOR_PREFIX";
      fi
      printf "$(gum style --bold "New default menu item prefix:") \
$GUM_CHOOSE_CURSOR_PREFIX\n";
      menu_customize_interface;
      ;;
    "Selected Menu Item")
      print_section_heading "Selected Menu Item";
      printf "$(gum style --italic "Enter a new selected menu item prefix.")\n";
      printf "$(gum style --bold "Old selected menu item prefix:") \
$GUM_CHOOSE_SELECTED_PREFIX\n";
      NEW_SELECTED_MENU_ITEM_PREFIX=$(gum input --placeholder "y");
      if ! [ -z "$NEW_SELECTED_MENU_ITEM_PREFIX" ]; then
        GUM_CHOOSE_SELECTED_PREFIX=$NEW_SELECTED_MENU_ITEM_PREFIX;
        update_instally_conf "CHOOSE_SELECTED" "$GUM_CHOOSE_SELECTED_PREFIX";
      fi
      printf "$(gum style --bold "New unselected menu item prefix:") \
$GUM_CHOOSE_SELECTED_PREFIX\n";
      menu_customize_interface;
      ;;
    "Back")
      menu_customize_appearance;
  esac
}

# Menu used to select groups of packages for installation.
# Invokes `menu_package_select` after user selects (or doesn't select)
# groups of packages.
menu_select_groups () {
  PACKAGES_INSTALLED=0;
  check_package_json;
  local HAS_GROUPS=$(jq 'has("groups")' $PACKAGE_JSON);
  if [ "$HAS_GROUPS" = "true" ]; then
    local GROUPS_ARRAY=$(jq '.groups' $PACKAGE_JSON);
    local GROUPS_ARRAY_LENGTH=$(echo "$GROUPS_ARRAY" | jq 'length');
    local MENU_ITEMS_ARRAY=();
    for (( i=0; i<$GROUPS_ARRAY_LENGTH; i++ )); do
      local GROUP=$(echo "$GROUPS_ARRAY" | \
        jq --argjson INDEX $i '.[$INDEX]');
      local GROUP_NAME=$(echo "$GROUP" | jq -r '.group'); 
      local GROUP_HAS_DESCRIPTION=$(echo "$GROUP" | jq -r 'has("description")');
      if [ "$GROUP_HAS_DESCRIPTION" = "true" ]; then
        local GROUP_DESCRIPTION=$(echo "$GROUP" | jq -r '.description');
        local MENU_ITEM="$(gum style --bold "$GROUP_NAME ¬ª") $GROUP_DESCRIPTION";
        MENU_ITEMS_ARRAY+=("$MENU_ITEM");
      else
        local MENU_ITEM="$(gum style --bold "$GROUP_NAME")";
        MENU_ITEMS_ARRAY+=("$MENU_ITEM");
      fi
    done
    print_select_groups;
    SELECTED_GROUPS=$(gum choose --no-limit \
      --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
      --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
      --cursor="$GUM_CHOOSE_CURSOR " \
      --cursor-prefix="$GUM_CHOOSE_CURSOR_PREFIX " \
      --selected-prefix="$GUM_CHOOSE_SELECTED_PREFIX " \
      --unselected-prefix="$GUM_CHOOSE_UNSELECTED_PREFIX " \
      "${MENU_ITEMS_ARRAY[@]}");
    SELECTED_GROUPS_ARRAY=();
    readarray -t SELECTED_GROUPS_ARRAY <<< "$SELECTED_GROUPS"
    if [ "${#SELECTED_GROUPS_ARRAY[@]}" -eq 1 ] \
      && [[ ${SELECTED_GROUPS_ARRAY[0]} == "" ]]; then
      printf "No groups selected.\n";
      menu_install_packages;
    else
      print_list "${SELECTED_GROUPS_ARRAY[@]}";
      menu_install_packages "${SELECTED_GROUPS_ARRAY[@]}";
    fi
  else
    menu_install_packages;
  fi
}

# Menu used to select packages for installation.
# Args:
#   `$@` - Array of selected package groups.
menu_install_packages () {
  local SELECTED_GROUPS_ARRAY=("$@");
  local GROUP_NAMES=();
  for GROUP in "${SELECTED_GROUPS_ARRAY[@]}"; do
    local GROUP_NAME=$(print_selected_menu_item "$GROUP");
    GROUP_NAMES+=("$GROUP_NAME");
  done
  # Get the eligible package menu items for display, given the selected package
  # groups.
  local MENU_ITEMS=($(get_menu_items "${GROUP_NAMES[@]}"));
  IFS=$'\n';
  readarray -t MENU_ITEMS_ARRAY <<< "$MENU_ITEMS";
  IFS="$DELIMITER";
  print_install_packages;
  # User selects packages to install:
  local SELECTED_PACKAGES=$(gum choose --no-limit \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor-prefix="$GUM_CHOOSE_CURSOR_PREFIX " \
    --selected-prefix="$GUM_CHOOSE_SELECTED_PREFIX " \
    --unselected-prefix="$GUM_CHOOSE_UNSELECTED_PREFIX " \
    "${MENU_ITEMS_ARRAY[@]}");
  # Roll selected packages into an array.
  local SELECTED_PACKAGES_ARRAY=();
  readarray -t SELECTED_PACKAGES_ARRAY <<< "$SELECTED_PACKAGES";
  # If no packages are selected, return to main menu.
  if [ "${#SELECTED_PACKAGES_ARRAY[@]}" -eq 1 ] && \
    [[ ${SELECTED_PACKAGES_ARRAY[0]} == "" ]]; then
    printf "No packages selected.\n"
    menu_main;
  # Otherwise, install the selected packages.
  else
    print_list "${SELECTED_PACKAGES_ARRAY[@]}";
    install_packages "${SELECTED_PACKAGES_ARRAY[@]}";
  fi
}

# Prompts the user whether or not they'd like to install more packages.
# Returns to package group select if so,
# Returns to main menu if not.
menu_install_more_packages () {
  INSTALL_MORE=$(gum confirm "Install more packages?" \
    --selected.background="$GUM_CONFIRM_SELECTED_BACKGROUND");
  if [ $? == 0 ]; then
    menu_select_groups;
  else
    menu_main;
  fi
}

# Prompts user whether they'd like to edit `package.json`.
# Opens `package.json` in an editor if so,
# Returns to main menu if not.
prompt_edit_package_json () {
  printf "$(gum style --italic \
    'To define packages for instally to install, edit') ";
  printf "$(gum style --bold \
    'package.json').\n";
  printf "$(gum style --bold --italic 'Instructions:') ";
  printf "https://github.com/jelizaga/instally/#-packagejson\n";
  EDIT_PACKAGE_JSON=$(gum confirm \
    "üìí Edit $(gum style --bold 'package.json')?" \
    --selected.background="$GUM_CONFIRM_SELECTED_BACKGROUND");
  if [ $? == 0 ]; then
    # If user hasn't set their `$EDITOR`, use `nano` to edit `package.json`,
    if [ -z $EDITOR ]; then
      nano $PACKAGE_JSON;
    # Otherwise, use their `$EDITOR` to edit `package.json`.
    elif [ -n $EDITOR ]; then
      $EDITOR $PACKAGE_JSON;
    fi
  else
    menu_main;
  fi 
}

################################################################################
# Printing #####################################################################
################################################################################
# Functions related to printing reusable messages and text.

# Prints declaration that a package has already been installed.
# Args:
#   `$1` - Name of the installed package.
print_already_installed () {
  local PACKAGE_NAME=$1;
  if ! package_is_installed gum; then
    printf "üëç $PACKAGE_NAME is already installed.\n";
  else
    printf "üëç $(gum style --bold "$PACKAGE_NAME") is already installed.\n";
  fi
}

# Prints a message declaring that a given package could not be installed.
# Args:
#   `$1` - Name of package that could not be installed.
#   `$2` - Optional reason why the package could not be installed.
print_cannot_install () {
  local PACKAGE_NAME=$1;
  if [ -n "$2" ]; then
    local REASON=$2;
    if ! package_is_installed gum; then
      printf "‚ùó $PACKAGE_NAME could not be installed: \
$REASON\n";
    else
      printf "‚ùó $(gum style --bold "$PACKAGE_NAME") could not be installed: \
$REASON\n";
    fi
  else
    if ! package_is_installed gum; then
      printf "‚ùó $PACKAGE_NAME could not be installed.\n";
    else
      printf "‚ùó $(gum style --bold "$PACKAGE_NAME") could not be installed.\n";
    fi
  fi
}

# Prints a message declaring that a given package cannot be installed until
# the new Node.js version manager is loaded by a reloaded terminal.
# Args:
#   `$1` - Name of the package that could not be installed.
print_cannot_install_new_node_version_manager () {
  local PACKAGE_NAME=$1;
  print_cannot_install "$PACKAGE_NAME" "\n\
  $(gum style --bold "$NEWLY_INSTALLED_NODE_VERSION_MANAGER") \
was installed as a Node.js version manager,\n  but $(gum style --bold "npm") \
cannot install anything until you restart the terminal.";
}

# Prints declaration that something has been created.
# Args:
#   `$1` - Name of item that has been created.
#   `$2` - Icon prefixing this message‚Äîan emoji or some unicode glyph.
print_created () {
  local ITEM=$1;
  local ICON=$2;
  printf "$ICON $(gum style --bold "$ITEM") created.\n";
}

# Prints declaration that a dependency is missing.
# Args:
#   `$1` - Name of the dependency required.
print_dependency_needed () {
  local DEPENDENCY=$1;
  if [ -n $2 ]; then 
    local DEPENDENCY_DEPENDENCY=$2;
    if ! package_is_installed gum; then
      printf "üî© We need $DEPENDENCY_DEPENDENCY to install $DEPENDENCY.\n";
    else
      printf "üî© We need $(gum style --bold "$DEPENDENCY_DEPENDENCY") \
to install $(gum style --bold "$DEPENDENCY").\n";
    fi
  else
    if ! package_is_installed gum; then
      printf "üî© We need $DEPENDENCY.\n";
    else
      printf "üî© We need $(gum style --bold "$DEPENDENCY").\n";
    fi
  fi
}

# Prints warning that something is empty.
# Args:
#   `$1` - Name of item that is empty.
#   `$2` - Icon prefixing this message‚Äîan emoji or some unicode glyph.
print_empty () {
  local ITEM=$1;
  if [ -n "$2" ]; then
    local ICON=$2;
    printf "$ICON $(gum style --bold "$ITEM") is empty.\n";
  else
    printf "‚ùå $(gum style --bold "$ITEM") is empty.\n";
  fi
}

# Prints error message.
# Args:
#   `$1` - Message to print.
print_error () {
  local MESSAGE=$1;
  if ! package_is_installed gum; then
    printf "üêõ Error: $MESSAGE\n";
  else
    printf "üêõ $(gum style --bold 'Error:') $MESSAGE\n";
  fi
}

# Prints a message declaring that a given package could not be installed due to
# its installation method missing.
# Args:
#   `$1` - Name of the package that could not be installed.
#   `$2` - Name of the installation method for `$1` that is missing.
print_installation_method_missing () {
  local PACKAGE_NAME=$1;
  local INSTALLATION_METHOD=$2;
  print_cannot_install "$PACKAGE_NAME" "$INSTALLATION_METHOD is \
$PACKAGE_NAME's installation method, but $INSTALLATION_METHOD is missing.\n\
  Try updating $PACKAGE_JSON with an available installation method for \
$PACKAGE_NAME.";
}

# Prompts user to select packages for installation and provides instructions.
# Associated with `menu_install_packages`.
print_install_packages () {
  print_section_heading "Install Packages";
  printf "$(gum style --italic 'Press ')";
  printf "$(gum style --bold --foreground "$COLOR_ACTIVE" 'x')";
  printf "$(gum style --italic ' to select packages to install')\n";
  printf "$(gum style --italic 'press ')"
  printf "$(gum style --bold --foreground "$COLOR_ACTIVE" 'a')";
  printf "$(gum style --italic ' to select all')\n";
  printf "$(gum style --italic 'press ')";
  printf "$(gum style --bold --foreground "$COLOR_ACTIVE" 'enter')";
  printf "$(gum style --italic ' to confirm your selection:')\n";
}

# Prints user input, as if the user had said it themselves.
# Args:
#   `$1` - Input to print.
print_input_speech () {
  local INPUT=$1;
  printf "üí¨ \"$INPUT\"\n";
}

print_input_selection () {
  local SELECTION=$1;
  printf "$(gum style --foreground "$COLOR_ACCENT" "$GUM_CHOOSE_CURSOR") \
$SELECTION\n";
}

# Prints declaration that a package has been successfully installed.
# Args:
#   `$1` - Name of the installed package.
#   `$2` - Optional name of the installation method used to install the package.
print_installed () {
  local PACKAGE_NAME=$1;
  if [ -n "$2" ]; then
    local INSTALLATION_METHOD=$2;
    if ! package_is_installed gum; then
      printf "üéÅ $PACKAGE_NAME \
installed using $INSTALLATION_METHOD.\n";
    else
      printf "üéÅ $(gum style --bold "$PACKAGE_NAME") \
installed using $(gum style --bold "$INSTALLATION_METHOD").\n";
    fi
  else
    if ! package_is_installed gum; then
      printf "üéÅ $PACKAGE_NAME installed.\n";
    else
      printf "üéÅ $(gum style --bold "$PACKAGE_NAME") installed.\n";
    fi
  fi
}

# Prints declaration that a package is currently being installed.
# Args:
#   `$1` - Name of the package being installed.
#   `$2` - ID of the package being installed (`"id"` in `package.json`).
#   `$3` - Installation method being used to install the package.
print_installing () {
  local PACKAGE_NAME=$1;
  local PACKAGE_ID=$2;
  local INSTALLATION_METHOD=$3;
  if ! package_is_installed gum; then
    printf "üåé Installing $PACKAGE_NAME ($PACKAGE_ID) \
using $INSTALLATION_METHOD...\n"
  else
    printf "Installing $(gum style --bold "$PACKAGE_NAME") \
($(gum style --italic "$PACKAGE_ID")) \
using $(gum style --bold "$INSTALLATION_METHOD")...";
  fi
}

# Prints the given array of items as a comma-separated list.
# Args:
#   `$@` - Array of items to print.
print_list () {
  local ARRAY=("$@");
  local LIST="";
  if [ "${#ARRAY[@]}" -eq 1 ]; then
    print_input_selection "$(print_selected_menu_item "${ARRAY[0]}").";
  else
    local INPUT="";
    local SELECTED_GROUPS_ARRAY_LENGTH=${#ARRAY[@]};
    for (( i=0; i<$((${#ARRAY[@]} - 1)); i++ )); do
      local GROUP_NAME=$(print_selected_menu_item "${ARRAY[i]}");
      LIST+="$GROUP_NAME, ";
    done
    LIST+="and $(print_selected_menu_item "${ARRAY[-1]}").";
    printf "$LIST";
  fi
}

# Prints declaration that a package cannot be installed due to a missing "id".
# Args:
#   `$1` - Name of the package being installed.
#   `$2` - Name of the installation method used to install the package.
print_missing_id () {
  local PACKAGE_NAME=$1;
  local INSTALLATION_METHOD=$1;
  print_cannot_install "$PACKAGE_NAME" \
    "$(gum style --bold "$INSTALLATION_METHOD") was chosen \
to install $PACKAGE_NAME, \
but $PACKAGE_NAME doesn't have an \"id\" for \"$INSTALLATION_METHOD\".";
  print_protip "Try adding an \"id\" to $PACKAGE_NAME's \
\"$INSTALLATION_METHOD\" installation method.";
}


# Prints declaration that a package cannot be installed due to a missing "id".
# Args:
#   `$1` - Name of the package being installed.
#   `$2` - Name of the installation method used to install the package.
print_missing_path () {
  local PACKAGE_NAME=$1;
  local INSTALLATION_METHOD=$1;
  print_cannot_install "$PACKAGE_NAME" \
    "$(gum style --bold "$INSTALLATION_METHOD") was chosen \
to install $PACKAGE_NAME, \
but $PACKAGE_NAME doesn't have a \"path\" for \"$INSTALLATION_METHOD\".";
  print_protip "Try adding a \"path\" to $PACKAGE_NAME's \
\"$INSTALLATION_METHOD\" installation method.";
}

# Prints warning that an expected package is missing.
# Args:
#   `$1` - Name of the missing package.
#   `$2` - Optional requirement that would be fulfilled by having package `$1`.
print_not_installed () {
  local PACKAGE_NAME=$1;
  if [ -n "$2" ]; then
    local REQUIREMENT=$2;
    if ! package_is_installed gum; then
      printf "‚ùå $PACKAGE_NAME \
is required to $REQUIREMENT, \
but $PACKAGE_NAME is missing.\n";
    else
      printf "‚ùå $(gum style --bold "$PACKAGE_NAME") \
is required to $REQUIREMENT, \
but $PACKAGE_NAME is missing.\n";
    fi
  else
    if ! package_is_installed gum; then
      printf "‚ùå $PACKAGE_NAME is missing.\n";
    else
      printf "‚ùå $(gum style --bold "$PACKAGE_NAME") is missing.\n";
    fi
  fi
}

# Prints the OS of the system running `instally`.
print_os () {
  printf "$(gum style --bold 'OS:') $OS_PRETTY_NAME\n"
}

# Prints warning that an expected field is missing from `package.json`.
# Args:
#    `$1` - Name of field missing from `package.json`.
print_package_json_missing_field () {
  local FIELD=$1;
  printf "‚ùó No $(gum style --bold "$FIELD") field \
found in $(gum style --bold "$PACKAGE_JSON").\n";
}

# Prints the amount of packages installed.
print_packages_installed () {
  if [ $PACKAGES_INSTALLED  -gt 1 ]; then
    printf "üè°üöõ $PACKAGES_INSTALLED packages installed.\n"
  elif [ $PACKAGES_INSTALLED -eq 1 ]; then
    printf "üè°üöö One package installed.\n"
  else
    printf "üè°üõª No packages installed.\n"
  fi
}

# Prints a useful protip.
# Args:
#   `$1` - Protip to print.
print_protip () {
  local PROTIP=$1;
  if ! package_is_installed gum; then
    printf "üëâ Protip: $PROTIP\n";
  else
    printf "$(gum style --bold 'Protip:') $PROTIP\n";
  fi
}

# Prints the end of a section.
#   `$1` - Width of the section's title, in characters.
print_section_end () {
  local WIDTH=$1;
  for i in $(seq 1 $NUMBER); do
    printf "$(gum style --bold '‚ñî')";
  done
  printf "\n\n";
}

# prints the heading of a section.
print_section_heading () {
  local HEADING=$1;
  printf "\n";
  printf "$(gum style --bold --underline "$HEADING")\n";
}

# Prints the string preceding ¬ª in a menu item, sanitized of ANSI styling.
# Args:
#   `$1` - Menu item.
print_selected_menu_item () {
  local SELECTION=$(echo "$1" | \
    sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | \
    awk -F " ¬ª" '{print $1}');
  echo "$SELECTION";
}

# Prints the name of a package, given its menu item string.
#   `$1` - Menu item of a package.
print_selected_package_name () {
  local PACKAGE_NAME=$(echo "$1" | \
    sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | \
    awk -F "/ " '{print $NF}' | awk -F " ¬ª" '{print $(NF-1)}');
  echo "$PACKAGE_NAME";
}

# Prints an 'under construction' message.
# Args:
#   `$1` - Optional name of incomplete feature.
print_todo () {
  if [ -n "$1" ]; then
    local FEATURE=$1;
    printf "üöß $FEATURE is under construction.\n";
  else
    printf "üöß Under construction.\n";
  fi
}

# Prints install+'s title.
print_title () {
  if ! package_is_installed gum; then
    printf "\n";
    printf "        welcome to\n";
    printf "   \"                    m           \"\"#    \"\"#          \n";
    printf " mmm    m mm    mmm   mm#mm   mmm     #      #    m   m\n";
    printf "   #    #\"  #  #   \"    #    \"   #    #      #    \"m m\" \n";
    printf "   #    #   #   \"\"\"m    #    m\"\"\"#    #      #     #m#  \n";
    printf " mm#mm  #   #  \"mmm\"    \"mm  \"mm\"#    \"mm    \"mm   \"#  \n";
    printf "                                                   m\"   \n";
    printf "                                                  \"\"    \n";
  else
    printf "\n";
    printf "$(gum style --italic --foreground "$COLOR_ACCENT" '        welcome to')\n";
    printf "$(gum style --bold --foreground "$COLOR_ACCENT" '   \"                    m           \"\"#    \"\"#          ')\n";
    printf "$(gum style --bold --foreground "$COLOR_ACCENT" ' mmm    m mm    mmm   mm#mm   mmm     #      #    m   m')\n";
    printf "$(gum style --bold --foreground "$COLOR_ACCENT" '   #    #\"  #  #   \"    #    \"   #    #      #    \"m m\" ')\n";
    printf "$(gum style --bold --foreground "$COLOR_ACCENT" '   #    #   #   \"\"\"m    #    m\"\"\"#    #      #     #m#  ')\n";
    printf "$(gum style --bold --foreground "$COLOR_ACCENT" ' mm#mm  #   #  \"mmm\"    \"mm  \"mm\"#    \"mm    \"mm   \"#  ')\n";
    printf "$(gum style --bold --foreground "$COLOR_ACCENT" '                                                   m\"   \n')";
    printf "$(gum style --bold --foreground "$COLOR_ACCENT" '                                                  \"\"    ')\n";
  fi
}

# Prints declaration that a package manager has been successfully updated.
# Args:
#   `$1` - Name of the updated package manager.
print_updated () {
  local PACKAGE_MANAGER=$1;
  if ! package_is_installed gum; then
    printf "‚ú® $PACKAGE_MANAGER updated.\n";
  else
    printf "‚ú® $(gum style --italic --bold "$PACKAGE_MANAGER") \
$(gum style --italic 'updated.')\n";
  fi
}

# Prompts user to select package groups and provides instructions.
# Associated with `menu_select_groups`.
print_select_groups () {
  print_section_heading "Select Groups";
  printf "$(gum style --italic 'Press ')";
  printf "$(gum style --bold --foreground "$COLOR_ACTIVE" 'x')";
  printf "$(gum style --italic ' to select package groups')\n";
  printf "$(gum style --italic 'press ')"
  printf "$(gum style --bold --foreground "$COLOR_ACTIVE" 'a')";
  printf "$(gum style --italic ' to select all')\n"
  printf "$(gum style --italic 'press ')"
  printf "$(gum style --bold --foreground "$COLOR_ACTIVE" 'enter')"
  printf "$(gum style --italic ' to confirm your selection:')\n"
}

# Prints warning message.
# Args:
#   `$1` - Message to print.
print_warning () {
  local MESSAGE=$1;
  printf "‚ö†Ô∏è $(gum style --bold 'Warning:') $MESSAGE\n";
}

# Getting data #################################################################
# Functions related to getting, shaping, and printing data from `package.json`.
################################################################################

# Prints array of package menu items from a given array of package groups
# combined with all ungrouped packages from the `PACKAGE_JSON`.
# Args:
#   `$@` - Array of package groups.
get_menu_items () {
  local PACKAGES_ARRAY=();
  local GROUPED_PACKAGES=();
  local UNGROUPED_PACKAGES=();
  if ! [ $# -eq 0 ]; then
    local GROUPS_ARRAY=("$@");
    GROUPED_PACKAGES=($(get_grouped_menu_items "${GROUPS_ARRAY[@]}"));
    PACKAGES_ARRAY+=( "${GROUPED_PACKAGES[@]}" );
  fi
  UNGROUPED_PACKAGES=($(get_ungrouped_menu_items));
  PACKAGES_ARRAY+=( "${UNGROUPED_PACKAGES[@]}" );
  printf '%s\n' "${PACKAGES_ARRAY[@]}";
}

# Given an array of package groups, prints a combined array of package menu
# items from the given package groups.
# Items are `\n` separated.
# Args:
#   `$@` - Array of package groups.
get_grouped_menu_items () {
  local GROUPS_ARRAY=("$@");
  local GROUPED_MENU_ITEMS_ARRAY=();
  local GROUP_COUNT=0;
  # For every given package group,
  for GROUP in "${GROUPS_ARRAY[@]}"; do
    ACTIVE_GROUP="$GROUP";
    ((GROUP_COUNT++));
    # Get an array of packages found in that group in `PACKAGE_JSON`,
    PACKAGES_IN_GROUP=$(jq -r --arg GROUP "$GROUP" \
      '.groups | map(select(.group == $GROUP))[0].packages' \
      $PACKAGE_JSON);
    # And if that array isn't empty,
    if ! [[ "$PACKAGES_IN_GROUP" == "null" ]]; then
      # Construct an array of menu items, one per package in the group.
      local MENU_ITEMS_FROM_GROUP=$(get_menu_items_from_array \
        "${PACKAGES_IN_GROUP[@]}");
      GROUPED_MENU_ITEMS_ARRAY+=( "${MENU_ITEMS_FROM_GROUP[@]}" );
    fi
  done
  # Print the resulting array of package menu items.
  printf '%s\n' "${GROUPED_MENU_ITEMS_ARRAY[@]}";
}

# Prints an array of package menu items from the ungrouped packages found in
# `PACKAGE_JSON`.
# Items are `\n` separated.
get_ungrouped_menu_items () {
  ACTIVE_GROUP="";
  # Get all ungrouped packages from `PACKAGE_JSON`,
  local UNGROUPED_PACKAGES=$(jq -r '.packages' \
    $PACKAGE_JSON);
  # If there's any ungrouped packages at all,
  if ! [[ "$UNGROUPED_PACKAGES" == "null" ]]; then
    # Construct and print an array of menu items, one per ungrouped package.
    local UNGROUPED_MENU_ITEMS_ARRAY=$(get_menu_items_from_array \
      "${UNGROUPED_PACKAGES[@]}");
    printf '%s\n' "${UNGROUPED_MENU_ITEMS_ARRAY[@]}";
  fi
}

# Prints an array of package menu items, given an array of valid package data.
# Items are `\n` separated.
# Args:
#   `$@` - Array of valid package data.
get_menu_items_from_array () {
  local ARRAY=("$@");
  local ARRAY_LENGTH=$(echo "$ARRAY" | \
    jq 'length');
  local MENU_ITEMS_ARRAY=();
  # For every package in the given array,
  for (( i=0; i<$ARRAY_LENGTH; i++ )); do
    # Construct a menu item string including the package name and its optional
    # description, and stick it in an array of menu items.
    local PACKAGE=$(echo "$ARRAY" | \
      jq --argjson INDEX $i '.[$INDEX]');
    PACKAGE_NAME=$(echo "$PACKAGE" | jq -r '.name');
    PACKAGE_HAS_DESCRIPTION=$(echo "$PACKAGE" | jq -r 'has("description")');
    if [ "$PACKAGE_HAS_DESCRIPTION" = "true" ]; then
      PACKAGE_DESCRIPTION=$(echo "$PACKAGE" | jq -r '.description');
      if ! [ -z "$ACTIVE_GROUP" ]; then
        MENU_ITEM="$(gum style --bold "$ACTIVE_GROUP / $PACKAGE_NAME ¬ª") $PACKAGE_DESCRIPTION";
      else
        MENU_ITEM="$(gum style --bold "$PACKAGE_NAME ¬ª") $PACKAGE_DESCRIPTION";
      fi
      MENU_ITEMS_ARRAY+=("$MENU_ITEM");
    else
      if ! [ -z "$ACTIVE_GROUP" ]; then
        MENU_ITEM="$(gum style --bold "$ACTIVE_GROUP / $PACKAGE_NAME")"
      else
        MENU_ITEM="$(gum style --bold "$PACKAGE_NAME")"
      fi
      MENU_ITEMS_ARRAY+=("$MENU_ITEM");
    fi
  done
  # Print the resulting array of menu items.
  printf '%s\n' "${MENU_ITEMS_ARRAY[@]}";
}

# Package detection ############################################################
# Functions related to detecting whether a package is installed or not.
################################################################################

# Determines whether a package is installed, given its command to run and
# whether or not it returns `0`.
# Args:
#   `$1` - Command used by the package.
package_is_installed () {
  command -v $1 >& /dev/null
  if [ $? == 1 ]; then
    false
  else
    true
  fi
} 

# Package manager installation #################################################
# Functions related to installing package managers.
################################################################################

# Installs dnf.
install_package_manager_dnf () {
  if $OS_IS_DEBIAN_BASED; then
    install_package_apt "dnf" "dnf";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  elif $OS_IS_RHEL_BASED; then
    install_package_yum "dnf" "dnf";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  elif $OS_IS_SUSE_BASED; then
    install_package_zypper "dnf" "dnf";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  else
    return 1;
  fi
}

# Installs Go.
install_package_manager_go () {
  if $OS_IS_DEBIAN_BASED; then
    install_package_apt golang-go;
  elif $OS_IS_RHEL_BASED; then
    install_package_dnf golang-go;
  # If OS is SUSE-based, install Go using Zypper,
  elif $OS_IS_SUSE_BASED; then
    if ! package_is_installed gum; then
      # No, I really have no idea wtf we have to install `gcc-go`, then `go`,
      # then remove `gcc-go` (in that exact order) to get Go working on SUSE.
      # I should really fix this in the future, but it's what works atm.
      print_installing "Go" "gcc-go" "zypper";
      sudo zypper install -y gcc-go > /dev/null;
      print_installing "Go" "go" "zypper";
      sudo zypper install -y go > /dev/null;
      sudo zypper remove -y gcc-go > /dev/null;
    else
      gum spin \
        --spinner globe \
        --title "$(print_installing "Go" "gcc-go" "zypper")" \
        -- sudo zypper install -y gcc-go;
      gum spin \
        --spinner globe \
        --title "$(print_installing "Go" "go" "zypper")" \
        -- sudo zypper install -y go;
      sudo zypper remove -y gcc-go > /dev/null;
    fi
    # If Go was successfully installed,
    if [ $? == 0 ]; then
      # Add the Go binaries to the user's `$PATH`,
      export PATH=$PATH:$HOME/go/bin;
      # Add them permanently to the user's `$PATH` if they have a `.bashrc` or
      # `.zshrc`.
      if [ -s $HOME/.bashrc ]; then
        echo 'export PATH=$PATH:$HOME/go/bin' >> $HOME/.bashrc;
        return 0;
      fi 
      if [ -s $HOME/.zshrc ]; then
        echo 'export PATH=$PATH:$HOME/go/bin' >> $HOME/.zshrc;
        return 0;
      fi 
    else
      print_cannot_install "Go" "Please try installing Go manually.";
      return 1;
    fi
  fi
}

# Installs flatpak.
install_package_manager_flatpak () {
  if $OS_IS_DEBIAN_BASED; then
    install_package_apt "flatpak" "flatpak";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  elif $OS_IS_RHEL_BASED; then
    install_package_dnf "flatpak" "flatpak";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  elif $OS_IS_SUSE_BASED; then
    install_package_zypper "flatpak" "flatpak";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  else
    return 1;
  fi
}

# Installs npm.
install_package_manager_npm () {
  if ! package_is_installed node; then
    printf "  Node.js is not installed.\n";
    install_node_version_manager;
  else
    printf "  Node.js is installed, but npm is missing. instally cannot resolve \
this.\n";
    printf "  ‚Üë Refer to https://nodejs.org/ for help.\n"
    return 1;
  fi
}

# Installs a Node.js version manager.
install_node_version_manager () {
  print_section_heading "Select Node.js Version Manager";
  printf "$(gum style --bold --underline 'Select Node.js Version Manager')\n";
  printf "$(gum style --italic 'Choose a') $(gum style --italic --bold \
'Node.js version manager') $(gum style --italic 'to install:')\n";
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "$(gum style --bold 'nvm ¬ª') https://github.com/nvm-sh/nvm" \
    "$(gum style --bold 'fnm ¬ª') https://github.com/Schniz/fnm" \
    "$(gum style --bold 'None')");
  SELECTED=$(echo "$SELECTED" | \
    sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | \
    awk -F " ¬ª" '{print $1}');
  print_input_selection "$SELECTED";
  case $SELECTED in
    "nvm")
      install_node_version_manager_nvm;
      if [ $? == 0 ]; then
        return 0;
      else
        return 1;
      fi
      ;;
    "fnm")
      install_node_version_manager_fnm;
      if [ $? == 0 ]; then
        return 0;
      else
        return 1;
      fi
      ;;
    "None")
      print_section_heading "Installing Packages";
      return 1;
      ;;
    *)
      print_section_heading "Installing Packages";
      return 1;
      ;;
  esac 
}

# Prompts user to install a version of Node.js to install using either
# `nvm` or `fnm`.
# Args:
#   `$1` - Node version manager used to install Node.js.
install_node () {
  local NODE_VERSION_MANAGER=$1;
  print_section_heading "Select Node.js Version";
  printf "$(gum style --bold --underline "Select Node.js Version")\n";
  printf "$(gum style --italic "Which version of Node.js would you like") \
$(gum style --italic --bold "$NODE_VERSION_MANAGER") \
$(gum style --italic "to install?")\n";
  NODE_VERSION=$(gum input --placeholder "19");
  $NODE_VERSION_MANAGER install $NODE_VERSION;
  if [ $? == 0 ]; then
    printf "üéÅ Node $NODE_VERSION installed.";
    ((PACKAGES_INSTALLED++));
    print_section_heading "Installing Packages";
    return 0;
  else
    printf "‚ùå $(gum style --bold "$NODE_VERSION") \
is not a valid Node.js version.\n";
    install_node "$NODE_VERSION_MANAGER";
  fi
}

# Installs nvm Node Version Manager.
install_node_version_manager_nvm () {
  print_section_heading "Installing Node.js Version Manager: nvm";
  curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash;
  print_section_heading "Installing Packages";
  if [ $? == 0 ]; then
    print_installed "nvm" "script @ https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh";
    NODE_VERSION_MANAGER_NEWLY_INSTALLED=true;
    NEWLY_INSTALLED_NODE_VERSION_MANAGER="nvm";
    return 0;
  else
    print_cannot_install "nvm";
    return 1;
  fi
}

# Installs fnm Node Version Manager.
install_node_version_manager_fnm () {
  print_section_heading "Installing Node.js Version Manager: fnm";
  curl -fsSL https://fnm.vercel.app/install | bash;
  print_section_heading "Installing Packages";
  if [ $? == 0 ]; then
    print_installed "fnm" "script @ https://fnm.vercel.app/install";
    NODE_VERSION_MANAGER_NEWLY_INSTALLED=true;
    NEWLY_INSTALLED_NODE_VERSION_MANAGER="fnm";
    return 0;
  else
    print_cannot_install "nvm";
    return 1;
  fi
}

# Installs pip.
install_package_manager_pip () {
  printf "\n";
  printf "$(gum style --bold --underline "Select pip to Install")\n";
  printf "$(gum style --italic \
"Which pip package manager would you like to install?")\n";
  local SELECTED=$(gum choose \
    --cursor="$GUM_CHOOSE_CURSOR " \
    --cursor.foreground="$GUM_CHOOSE_CURSOR_FOREGROUND" \
    --selected.foreground="$GUM_CHOOSE_SELECTED_FOREGROUND" \
    "$(gum style --bold 'pip3 ¬ª') pip for Python 3.x" \
    "$(gum style --bold 'pip2 ¬ª') pip for Python 2.7" \
    "$(gum style --bold 'pip3 + pip2 ¬ª') both pip3 & pip" \
    "$(gum style --bold 'None')");
  SELECTED=$(echo "$SELECTED" | \
    sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | \
    awk -F " ¬ª" '{print $1}');
  print_input_selection "$SELECTED";
  local INSTALL_PIP3=[ "$SELECTED" | grep -q "pip3" ];
  local INSTALL_PIP2=[ "$SELECTED" | grep -q "pip2" ];
  if [ "$SELECTED" = "None" ]; then
    return 1;
  elif $OS_IS_DEBIAN_BASED; then
    if $INSTALL_PIP3; then
      install_package_apt "python3-pip" "pip3";
    fi
    if $INSTALL_PIP2; then
      install_package_apt "python-pip" "pip2";
    fi
  elif $OS_IS_RHEL_BASED; then
    if $INSTALL_PIP3; then
      install_package_dnf "python3-pip" "pip3";
    fi
    if $INSTALL_PIP2; then
      if [ "$OS_NAME" = "CentOS Linux" ] || \
        [ "$OS_NAME" = "Red Hat Enterprise Linux" ]; then
        install_package_dnf \
"epel-release" "Extra Packages for Enterprise Linux";
      fi
      install_package_dnf "python-pip";
    fi
  elif $OS_IS_ZYPPER_BASED; then
    if $INSTALL_PIP3; then
      install_package_zypper "python3-pip" "pip3";
    fi
    if $INSTALL_PIP2; then
      install_package_zypper "python2-pip" "pip2";
    fi
  else
    print_cannot_install "pip3" "Try instructions @ \
https://pip.pypa.io/en/stable/installation/ \
to install pip and $PACKAGE_NAME.";
    return 1;
  fi
}

# Installs snap.
# Args:
#   `$1` - Name of the package that requires snap to be installed.
install_package_manager_snap () {
  local PACKAGE_NAME=$1;
  if $OS_IS_DEBIAN_BASED; then
    install_package_apt "snapd";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  elif $OS_IS_RHEL_BASED; then
    install_package_dnf "snapd";
    if [ $? == 0 ]; then
      return 0;
    else
      return 1;
    fi
  else
    return 1;
  fi
}

# Package installation  ########################################################
# Functions related to installing packages.
################################################################################

# Determines and `echo`s the install method of a package, given `PACKAGE_DATA`
# JSON.
# Args:
#   `$1` - JSON `PACKAGE_DATA` specific to a package.
get_installation_method () {
  local PACKAGE_DATA="$1";
  local INSTALLATION_METHOD="";
  # Get all available installation methods for the given package,
  APT=$(echo "$PACKAGE_DATA" | jq 'has("apt")');
  DNF=$(echo "$PACKAGE_DATA" | jq 'has("dnf")');
  FLATPAK=$(echo "$PACKAGE_DATA" | jq 'has("flatpak")');
  GO=$(echo "$PACKAGE_DATA" | jq 'has("go")');
  NPM=$(echo "$PACKAGE_DATA" | jq 'has("npm")');
  PIP=$(echo "$PACKAGE_DATA" | jq 'has("pip")');
  SNAP=$(echo "$PACKAGE_DATA" | jq 'has("snap")');
  YUM=$(echo "$PACKAGE_DATA" | jq 'has("yum")');
  ZYPPER=$(echo "$PACKAGE_DATA" | jq 'has("zypper")');
  COMMAND=$(echo "$PACKAGE_DATA" | jq 'has("command")');
  # Determine the installation method for the given package:
  HAS_PREFERRED_INSTALLATION_METHOD=$(echo "$PACKAGE_DATA" | \
    jq 'has("prefer")');
  # If there's a preferred installation method, use that‚Äîotherwise,
  if [ "$HAS_PREFERRED_INSTALLATION_METHOD" = "true" ]; then
    INSTALLATION_METHOD=$(echo "$PACKAGE_DATA" | jq -r '.prefer');
  # For Debian-based OS:
  # Prefer apt, then third-party, then command, and lastly
  # installation methods that are likely to be incompatible;
  elif $OS_IS_DEBIAN_BASED; then
    if [ "$APT" = "true" ]; then
      INSTALLATION_METHOD="apt";
    elif [ "$FLATPAK" = "true" ]; then
      INSTALLATION_METHOD="flatpak";
    elif [ "$GO" = "true" ]; then
      INSTALLATION_METHOD="go";
    elif [ "$NPM" = "true" ]; then
      INSTALLATION_METHOD="npm";
    elif [ "$PIP" = "true" ]; then
      INSTALLATION_METHOD="pip";
    elif [ "$SNAP" = "true" ]; then
      INSTALLATION_METHOD="snap";
    elif [ "$COMMAND" = "true" ]; then
      INSTALLATION_METHOD="command";
    elif [ "$DNF" = "true" ]; then
      INSTALLATION_METHOD="dnf"
    elif [ "$YUM" = "true" ]; then
      INSTALLATION_METHOD="yum"
    elif [ "$ZYPPER" = "true" ]; then
      INSTALLATION_METHOD="zypper";
    fi
  # For RHEL-based OS:
  # Prefer dnf, then yum, then third-party, then command, and lastly
  # installation methods that are likely to be incompatible;
  elif $OS_IS_RHEL_BASED; then
    if [ "$DNF" = "true" ]; then
      INSTALLATION_METHOD="dnf";
    elif [ "$YUM" = "true" ]; then
      INSTALLATION_METHOD="yum";
    elif [ "$FLATPAK" = "true" ]; then
      INSTALLATION_METHOD="flatpak";
    elif [ "$GO" = "true" ]; then
      INSTALLATION_METHOD="go";
    elif [ "$NPM" = "true" ]; then
      INSTALLATION_METHOD="npm";
    elif [ "$PIP" = "true" ]; then
      INSTALLATION_METHOD="pip";
    elif [ "$SNAP" = "true" ]; then
      INSTALLATION_METHOD="snap";
    elif [ "$COMMAND" = "true" ]; then
      INSTALLATION_METHOD="command";
    elif [ "$APT" = "true" ]; then
      INSTALLATION_METHOD="apt";
    elif [ "$ZYPPER" = "true" ]; then
      INSTALLATION_METHOD="zypper";
    fi
  # For SUSE-based OS:
  # Prefer zypper, then third-party, then command, and lastly
  # installation methods that are likely to be incompatible.
  elif $OS_IS_SUSE_BASED; then
    if [ "$ZYPPER" = "true" ]; then
      INSTALLATION_METHOD="zypper";
    elif [ "$FLATPAK" = "true" ]; then
      INSTALLATION_METHOD="flatpak";
    elif [ "$GO" = "true" ]; then
      INSTALLATION_METHOD="go";
    elif [ "$NPM" = "true" ]; then
      INSTALLATION_METHOD="npm";
    elif [ "$PIP" = "true" ]; then
      INSTALLATION_METHOD="pip";
    elif [ "$SNAP" = "true" ]; then
      INSTALLATION_METHOD="snap";
    elif [ "$COMMAND" = "true" ]; then
      INSTALLATION_METHOD="command";
    elif [ "$DNF" = "true" ]; then
      INSTALLATION_METHOD="dnf";
    elif [ "$YUM" = "true" ]; then
      INSTALLATION_METHOD="yum";
    elif [ "$APT" = "true" ]; then
      INSTALLATION_METHOD="apt";
    fi
  fi
  # Report the preferred installation method.
  echo "$INSTALLATION_METHOD";
}

# Installs packages given an array of package names.
# Args:
#   `$@` - Array of packages to install.
install_packages () {
  print_section_heading "Installing Packages";
  local PACKAGES_TO_INSTALL=("$@");
  # For every PACKAGE...
  for PACKAGE in "${PACKAGES_TO_INSTALL[@]}"; do
    # Capture the actual `PACKAGE_NAME` from the array and remove styling,
    PACKAGE_NAME=$(print_selected_package_name "$PACKAGE");
    local PACKAGE_DATA="";
    local HAS_UNGROUPED_PACKAGES=$(jq 'has("packages")' $PACKAGE_JSON);
    local HAS_GROUPED_PACKAGES=$(jq 'has("groups")' $PACKAGE_JSON);
    # Capture the package's data,
    if [ "$HAS_UNGROUPED_PACKAGES" = "true" ]; then
      UNGROUPED_PACKAGE_DATA=$(jq --arg PACKAGE_NAME "$PACKAGE_NAME" \
        '.packages[] | select(.name == $PACKAGE_NAME)' \
        $PACKAGE_JSON);
    fi
    if [ "$HAS_GROUPED_PACKAGES" = "true" ]; then
      GROUPED_PACKAGE_DATA=$(jq --arg PACKAGE_NAME "$PACKAGE_NAME" \
        '.groups[] | select(.packages != null) | .packages[] | select(.name == $PACKAGE_NAME)' \
        $PACKAGE_JSON);
    fi
    if [ -n "$GROUPED_PACKAGE_DATA" ] && \
      [ "$GROUPED_PACKAGE_DATA" != $'\n' ]; then
      PACKAGE_DATA="$GROUPED_PACKAGE_DATA";
    else
      PACKAGE_DATA="$UNGROUPED_PACKAGE_DATA";
    fi
    # And install the package.
    install_package "$PACKAGE_DATA";
  done
  print_packages_installed;
  menu_install_more_packages;
}

# Installs a package given `PACKAGE_DATA` JSON.
# Args:
#   `$1` - JSON `PACKAGE_DATA` specific to a package.
install_package () {
  local PACKAGE_DATA="$1";
  local PACKAGE_NAME=$(echo "$PACKAGE_DATA" | jq -r '.name' | tr -d '\n');
  local HAS_OS_PRETTY_NAME_INSTALLATION_METHODS=$(echo "$PACKAGE_DATA" | \
    jq --arg OS_PRETTY_NAME "$OS_PRETTY_NAME" 'has($OS_PRETTY_NAME)');
  local HAS_OS_NAME_INSTALLATION_METHODS=$(echo "$PACKAGE_DATA" | \
    jq --arg OS_NAME "$OS_NAME" 'has($OS_NAME)');
  # Narrow package data to installation methods relevant to the OS,
  # if specified in `package.json`:
  if [ "$HAS_OS_PRETTY_NAME_INSTALLATION_METHODS" = "true" ]; then
    PACKAGE_DATA=$(echo "$PACKAGE_DATA" | \
      jq --arg OS_PRETTY_NAME \
      "$OS_PRETTY_NAME" '.[$OS_PRETTY_NAME]');
  elif [ "$HAS_OS_NAME_INSTALLATION_METHODS" = "true" ]; then
    PACKAGE_DATA=$(echo "$PACKAGE_DATA" | \
      jq --arg OS_NAME \
      "$OS_NAME" '.[$OS_NAME]');
  fi
  # Determine the package's installation method;
  local INSTALLATION_METHOD="$(get_installation_method "$PACKAGE_DATA" 2>&1)";
  # If an installation method exists, install the package:
  if [ -n "$INSTALLATION_METHOD" ] && [ "$INSTALLATION_METHOD" != $'\n' ]; then
    # If the preferred installation method is a command, execute the command.
    if [ "$INSTALLATION_METHOD" = "command" ]; then
      COMMAND=$(echo "$PACKAGE_DATA" | jq -r '.command');
      install_package_command "$COMMAND" "$PACKAGE_NAME";
    # Otherwise, capture the `PACKAGE_ID` for the `INSTALLATION_METHOD`
    # and install the package using said `INSTALLATION_METHOD`.
    else
      local PACKAGE_ID="";
      if [ "$INSTALLATION_METHOD" = "go" ]; then
        PACKAGE_ID=$(echo "$PACKAGE_DATA" | \
          jq -r --arg INSTALLATION_METHOD "$INSTALLATION_METHOD" \
          ".$INSTALLATION_METHOD.path" || \
          print_missing_path "$PACKAGE_NAME" "$INSTALLATION_METHOD");
        return 1;
      else
        PACKAGE_ID=$(echo "$PACKAGE_DATA" | \
          jq -r --arg INSTALLATION_METHOD "$INSTALLATION_METHOD" \
          ".$INSTALLATION_METHOD.id" || \
          print_missing_id "$PACKAGE_NAME" "$INSTALLATION_METHOD");
      fi
      if [ "$INSTALLATION_METHOD" = "apt" ]; then
        install_package_apt "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "dnf" ]; then
        install_package_dnf "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "flatpak" ]; then
        install_package_flatpak "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "go" ]; then
        install_package_go "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "npm" ]; then
        install_package_npm "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "pip" ]; then
        install_package_pip "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "snap" ]; then
        install_package_snap "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "yum" ]; then
        install_package_yum "$PACKAGE_ID" "$PACKAGE_NAME";
      elif [ "$INSTALLATION_METHOD" = "zypper" ]; then
        install_package_zypper "$PACKAGE_ID" "$PACKAGE_NAME";
      fi
    fi
  # If there's no apparent installation method, say so.
  else
    print_cannot_install "$PACKAGE_NAME" "Installation method not found.";
    return 2;
  fi
}

# Installs a package using APT package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_apt () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  # If apt isn't installed, the package cannot be installed.
  if ! package_is_installed apt; then
    print_not_installed "apt" "install $PACKAGE_NAME";
    print_installation_method_missing "$PACKAGE_NAME" "apt";
    if $OS_IS_DEBIAN_BASED; then
      print_protip "$OS_NAME is a Debian-based OS, but appears to be missing \
apt.\n  Try using a dpkg command to reinstall apt.";
    fi
    if $OS_IS_RHEL_BASED; then
      print_protip "Since $OS_NAME is a RHEL-based OS, try using yum or dnf \
as $PACKAGE_NAME's installation method instead.";
    fi
    if $OS_IS_SUSE_BASED; then
      print_protip "Since $OS_NAME is a SUSE-based OS, try using zypper \
as $PACKAGE_NAME's installation method instead.";
    fi
    return 1;
  else
    # If package is already installed, say so.
    if dpkg -s $PACKAGE_ID >/dev/null 2>&1; then
      print_already_installed "$PACKAGE_NAME";
    # Otherwise,
    else
      # Update apt if it isn't already updated,
      if ! $APT_IS_UPDATED; then
        if ! package_is_installed gum; then
          printf "Updating apt to install $PACKAGE_NAME...\n";
          sudo apt-get update -y;
          print_updated "apt";
        else
          gum spin --spinner globe --title \
            "Updating $(gum style --bold "apt") to install $(gum style --bold "$PACKAGE_NAME")..." \
            -- sudo apt-get update -y;
        fi
        if [ $? == 0 ]; then
          APT_IS_UPDATED=true;
          print_updated "apt";
        else
          print_warning "apt could not be updated.";
        fi
      fi
      # And install the package.
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "apt";
        sudo apt-get install -y $PACKAGE_ID;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "apt")" \
          -- sudo apt-get install -y $PACKAGE_ID;
      fi
      # If package is successfully installed, say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "apt";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, print error messages.
      elif [ $? == 1 ] || [ $? == 100 ]; then
        print_cannot_install "$PACKAGE_NAME" "Package not found. \
Is $PACKAGE_ID the correct id?";
        return 1;
      elif [ $? == 101 ]; then
        print_cannot_install "$PACKAGE_NAME" "Download interrupted.";
        return 101;
      elif [ $? == 102 ]; then
        print_cannot_install "$PACKAGE_NAME" "Error encountered while \
unpacking package.";
        return 102;
      elif [ $? == 103 ]; then
        print_cannot_install "$PACKAGE_NAME" "Error encountered while \
configuring package.";
        return 103;
      elif [ $? == 104 ]; then
        print_already_installed "$PACKAGE_NAME";
        return 104;
      elif [ $? == 106 ]; then
        print_cannot_install "$PACKAGE_NAME" "Unsatisfied dependencies.";
        return 106;
      elif [ $? == 130 ]; then
        print_cannot_install "$PACKAGE_NAME" "Installation interrupted by user.";
        return 130;
      fi
    fi
  fi
}

# Installs a package using dnf package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_dnf () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  # If dnf isn't installed, try to install dnf.
  if ! package_is_installed dnf; then
    print_not_installed "dnf" "install $PACKAGE_NAME";
    install_package_manager_dnf;
    # If dnf is successfully installed, try installing the package again.
    if [ $? == 0 ]; then
      install_package_dnf "$PACKAGE_ID" "$PACKAGE_NAME";
    # Otherwise, try installing the package using yum.
    else
      printf "‚è≠Ô∏è dnf is missing. We'll try to install $PACKAGE_NAME with yum \
instead.\n"
      install_package_yum "$PACKAGE_ID" "$PACKAGE_NAME";
    fi
  # Otherwise, try to install the package using dnf,
  else
    # Check if the package is already installed using dnf,
    if dnf list installed | grep -q "$PACKAGE_ID"; then
      print_already_installed "$PACKAGE_NAME";
    # Otherwise, install the package.
    else
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "dnf";
        sudo dnf install -y $PACKAGE_ID;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "dnf")" \
          -- sudo dnf install -y $PACKAGE_ID;
      fi
      # If the package is successfully installed, say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "dnf";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, tell 'em the package can't be installed.
      else
        print_cannot_install "$PACKAGE_NAME";
        return 1;
      fi
    fi
  fi
}

# Installs a package using flatpak package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_flatpak () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  # If flatpak isn't installed, try to install flatpak.
  if ! package_is_installed flatpak; then
    print_not_installed "flatpak" "install $PACKAGE_NAME";
    install_package_manager_flatpak;
    if [ $? == 0 ]; then
      install_package_flatpak "$PACKAGE_ID" "$PACKAGE_NAME";
    else
      print_installation_method_missing "$PACKAGE_NAME" "flatpak";
      return 2;
    fi
  # Otherwise, try installing the package using flatpak,
  else
    # Check if the package is already installed using flatpak,
    if flatpak list | grep -q "$PACKAGE_ID"; then
      print_already_installed "$PACKAGE_NAME";
      return 0;
    # Otherwise, install package.
    else
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "flatpak";
        flatpak install -y $PACKAGE_ID;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "flatpak")" \
          -- flatpak install -y $PACKAGE_ID;
      fi
      # If package is successfully installed, say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "flatpak";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, print error messages.
      elif [ $? == 1 ]; then
        print_cannot_install "$PACKAGE_NAME" \
"Installation interrupted by user.";
        return 1;
      elif [ $? == 3 ]; then
        print_cannot_install "$PACKAGE_NAME" "User does not have permission \
to install packages with Flatpak."
        return 3;
      elif [ $? == 4 ]; then
        print_cannot_install "$PACKAGE_NAME" "Unresolvable dependencies. \
Try installing $(gum style --bold "$PACKAGE_NAME") manually.";
        return 4;
      elif [ $? == 5 ]; then
        print_already_installed "$PACKAGE_NAME";
        return 5;
      elif [ $? == 6 ]; then
        print_cannot_install "$PACKAGE_NAME" "Incompatible architecture.";
        return 6;
      elif [ $? == 7 ]; then
        print_cannot_install "$PACKAGE_NAME" "Remote repository unavailable.";
        return 7;
      elif [ $? == 8 ]; then
        print_cannot_install "$PACKAGE_NAME" "No such remote repository.";
        return 8;
      elif [ $? == 9 ]; then
        print_cannot_install "$PACKAGE_NAME" "Could not \
be downloaded from remote repository.";
        return 9;
      fi
    fi
  fi
}

# Installs a Go package using go.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_go () {
  local PACKGE_PATH=$1;
  local PACKAGE_NAME=$2;
  # If go isn't installed, try installing go.
  if ! package_is_installed go; then
    print_not_installed "go" "install $PACKAGE_NAME";
    install_package_manager_go;
    if [ $? == 0 ]; then
      install_package_go "$PACKAGE_PATH" "$PACKAGE_NAME";
    else
      print_installation_method_missing "$PACKAGE_NAME" "go";
      return 2;
    fi
  # Otherwise, try installing the package using go.
  else
    # Check if the package is already installed using go,
    if go list | grep -q "$PACKAGE_ID"; then
      print_already_installed "$PACKAGE_NAME";
    # And install the package.
    else
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_PATH" "go";
        go install $PACKAGE_PATH;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_PATH" "go")" \
          -- go install $PACKAGE_PATH;
      fi
      # If the package is successfully installed, say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "go";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, tell 'em the package cannot be installed.
      else
        print_cannot_install "$PACKAGE_NAME";
        return 1;
      fi
    fi
  fi
}

# Installs a package using npm package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_npm () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  # If nvm is installed, but Node isn't, install Node,
  if package_is_installed nvm && ! package_is_installed npm; then
    print_not_installed "Node.js" "install $(gum style --bold \ 
"$PACKAGE_NAME")";
    install_node "nvm";
    if [ $? == 0 ]; then
      install_package_npm "$PACKAGE_ID" "$PACKAGE_NAME";
    else
      print_cannot_install "$PACKAGE_NAME";
    fi
  # If fnm is installed, but Node isn't, install Node,
  elif package_is_installed fnm && ! package_is_installed npm; then
    print_not_installed "Node.js" "install $(gum style --bold \ 
"$PACKAGE_NAME")";
    install_node "fnm";
    if [ $? == 0 ]; then
      install_package_npm "$PACKAGE_ID" "$PACKAGE_NAME";
    else
      print_cannot_install "$PACKAGE_NAME";
    fi
  # If Node isn't installed, try to install Node,
  elif ! package_is_installed npm && \
    ! package_is_installed nvm && \
    ! package_is_installed fnm; then
    print_not_installed "npm" "install $(gum style --bold "$PACKAGE_NAME")";
    install_package_manager_npm;
    if [ $? == 0 ]; then
      print_cannot_install_new_node_version_manager "$PACKAGE_NAME";
    else
      print_installation_method_missing "$PACKAGE_NAME" "npm";
      return 2;
    fi
  # Otherwise, try installing the package using npm:
  else
    # Check if the package is already installed,
    if npm list -g --depth 0 | grep -q "$PACKAGE_ID"; then
      print_already_installed "$PACKAGE_NAME";
    # And install the package.
    else
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "npm";
        npm install -g $PACKAGE_ID;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "npm")" \
          -- npm install -g $PACKAGE_ID;
      fi
      # If the package was successfully installed, say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "npm";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, tell 'em the package can't be installed.
      else
        print_cannot_install "$PACKAGE_NAME";
        return 1;
      fi
    fi
  fi
}

# Installs a package using pip package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_pip () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  local PIP="pip3";
  if [ "$OS_NAME" = "CentOS Linux" ]; then
    PIP="pip3";
  fi
  # If pip isn't installed, try installing pip.
  if ! package_is_installed "$PIP"; then
    print_not_installed "pip" "install $PACKAGE_NAME";
    install_package_manager_pip;
    if [ $? == 0 ]; then
      install_package_pip "$PACKAGE_ID" "$PACKAGE_NAME";
    else
      print_cannot_install "$PACKAGE_NAME";
    fi
  # Otherwise, try installing the package using pip:
  else
    # Check if the package is already installed using pip,
    # (This is done by piping the output of `pip list` to a temporary file‚Äî
    # (why `pip list` won't `grep` normally, I have no idea.)
    $PIP list --format=freeze > $HOME/.instally/pip_list_$PACKAGE_ID.temp;
    if grep -q "$PACKAGE_ID" $HOME/.instally/pip_list_$PACKAGE_ID.temp; then
      print_already_installed "$PACKAGE_NAME";
      rm $HOME/.instally/pip_list_$PACKAGE_ID.temp;
    # And install the package.
    else
      rm $HOME/.instally/pip_list_$PACKAGE_ID.temp;
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "pip";
        $PIP install -q $PACKAGE_NAME;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "pip")" \
          -- $PIP install -q $PACKAGE_ID;
      fi
      # If the package is successfully installed, then say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "pip";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, tell 'em the package could not be installed.
      else
        print_cannot_install "$PACKAGE_NAME";
        return 1;
      fi 
    fi
  fi
}

# Installs a package using snap package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_snap () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  # If snap isn't installed, try to install snap,
  if ! package_is_installed snap; then
    print_not_installed "snap" "install $PACKAGE_NAME";
    install_package_manager_snap "$PACKAGE_NAME";
    # If snap is successfully installed, try installing the package again.
    if [ $? == 0 ]; then
      install_package_snap "$PACKAGE_ID" "$PACKAGE_NAME";
    # Otherwise, tell 'em neither snap or the package could be installed.
    else
      print_cannot_install "snap" "Try instructions @ \
https://snapcraft.io/install/$PACKAGE_ID/opensuse#install \
to install snap and $PACKAGE_NAME.";
      print_installation_method_missing "$PACKAGE_NAME" "snap";
      return 2;
    fi
  # Otherwise, try installing the package using snap:
  else
    # Check if the package is already installed using snap,
    if snap list | grep -q "$PACKAGE_ID"; then
      print_already_installed "$PACKAGE_NAME";
    # And install the package.
    else
      snap install $PACKAGE_ID;
      # If the package was successfully installed, then say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "snap";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, tell 'em the package can't be installed.
      else
        print_cannot_install "$PACKAGE_NAME";
        return 1;
      fi
    fi
  fi
}

# Installs a package using yum package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_yum () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  # If yum is not installed, the package cannot be installed.
  if ! package_is_installed yum; then
    print_not_installed "yum" "install $PACKAGE_NAME";
    print_installation_method_missing "$PACKAGE_NAME" "yum";
    if $OS_IS_RHEL_BASED; then
      print_protip "$OS_NAME is a RHEL-based OS, but appears to be missing \
yum.\n  Try using an rpm command to reinstall yum.";
    fi
    if $OS_IS_DEBIAN_BASED; then
      print_protip "Since $OS_NAME is a Debian-based OS, try using apt \
as $PACKAGE_NAME's installation method instead.";
    fi
    if $OS_IS_SUSE_BASED; then
      print_protip "Since $OS_NAME is a SUSE-based OS, try using zypper \
as $PACKAGE_NAME's installation method instead.";
    fi
    return 2;
  # Otherwise, try installing the package using yum:
  else
    # Check if the package is installed using yum,
    if yum list installed | grep -q "$PACKAGE_ID"; then
      print_already_installed "$PACKAGE_NAME";
    # And install the package.
    else
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_ID" yum;
        sudo yum install -y $PACKAGE_ID;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "yum")" \
          -- sudo yum install -y $PACKAGE_ID;
      fi
      # If the package was successfully installed, say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "yum";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, tell 'em the package can't be installed.
      else
        print_cannot_install "$PACKAGE_NAME";
        return 1;
      fi
    fi
  fi
}

# Installs a package using zypper package manager.
# Args:
#   `$1` - Valid package ID.
#   `$2` - Package name.
install_package_zypper () {
  local PACKAGE_ID=$1;
  local PACKAGE_NAME=$2;
  # If zypper is not installed, the package cannot be installed.
  if ! package_is_installed zypper; then
    print_not_installed "zypper" "install $PACKAGE_NAME";
    print_installation_method_missing "$PACKAGE_NAME" "zypper";
    if $OS_IS_RHEL_BASED; then
      print_protip "Since $OS_NAME is a RHEL-based OS, try using dnf or yum \
as $PACKAGE_NAME's installation method instead.";
    fi
    if $OS_IS_DEBIAN_BASED; then
      print_protip "Since $OS_NAME is a Debian-based OS, try using apt \
as $PACKAGE_NAME's installation method instead.";
    fi
    if $OS_IS_SUSE_BASED; then
      print_protip "$OS_NAME is a SUSE-based OS, but appears to be missing \
zypper.\n  Try reinstalling zypper.";
    fi
    return 2;
  # Otherwise, try installing the package using zypper:
  else
    # Check if the package is already installed using zypper,
    if zypper pa -i | grep -q "$PACKAGE_ID"; then
      print_already_installed "$PACKAGE_NAME";
    # And install the package.
    else
      if ! package_is_installed gum; then
        print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "zypper";
        sudo zypper install -y $PACKAGE_ID;
      else
        gum spin \
          --spinner globe \
          --title "$(print_installing "$PACKAGE_NAME" "$PACKAGE_ID" "zypper")" \
          -- sudo zypper install -y $PACKAGE_ID;
      fi
      # If the package was successfully installed, say so.
      if [ $? == 0 ]; then
        print_installed "$PACKAGE_NAME" "zypper";
        ((PACKAGES_INSTALLED++));
        return 0;
      # Otherwise, tell 'em the package cannot be installed.
      else
        print_cannot_install "$PACKAGE_NAME";
      fi
    fi
  fi
}

# Installs a package via a given command.
# Issues a warning regarding the inherent security risk of this installation
# method.
# Args:
#   `$1` - Installation command.
#   `$2` - Package name.
install_package_command () {
  local COMMAND=$1;
  local PACKAGE_NAME=$2;
  print_warning "Installing $(gum style --bold "$PACKAGE_NAME") \
using $(gum style --italic 'command').";
  eval $COMMAND;
  # If command exited 0, assume the package was successfully installed.
  if [ $? == 0 ]; then
    print_installed "$PACKAGE_NAME";
    ((PACKAGES_INSTALLED++));
  else
    print_warning "The last command exited with non-0 status.";
    printf "  $(gum style --bold "$PACKAGE_NAME") \
may not have been installed:\n";
    printf "  $(gum style --bold "1.") \
Check if $(gum style --bold "$PACKAGE_NAME") is installed.\n";
    printf "  $(gum style --bold "2.") \
Confirm that the $(gum style --bold "$PACKAGE_NAME") \
installation command in $PACKAGE_JSON is valid.\n";
  fi
}

################################################################################
################################################################################
################################################################################

sudo -v
check_os
check_dependencies
check_conf
if [ $? == 0 ]; then
  menu_main
fi
